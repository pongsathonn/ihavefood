net/http.ResponseWriter(*net/http.response) *{
	conn: *net/http.conn {
		server: *(*"net/http.Server")(0xc00037a000),
		cancelCtx: context.WithCancel.func1,
		rwc: net.Conn(*net.TCPConn) ...,
		remoteAddr: "172.27.0.1:40286",
		tlsState: *crypto/tls.ConnectionState nil,
		werr: error nil,
		r: *(*"net/http.connReader")(0xc00042a6f0),
		bufr: *(*bufio.Reader)(0xc000410120),
		bufw: *(*bufio.Writer)(0xc000418200),
		lastMethod: "POST",
		curReq: (*"sync/atomic.Pointer[net/http.response]")(0xc00042c190),
		curState: (*"sync/atomic.Uint64")(0xc00042c198),
		mu: (*sync.Mutex)(0xc00042c1a0),
		hijackedv: false,},
	req: *net/http.Request {
		Method: "POST",
		URL: *(*"net/url.URL")(0xc00042c1b0),
		Proto: "HTTP/1.1",
		ProtoMajor: 1,
		ProtoMinor: 1,
		Header: net/http.Header [...],
		Body: io.ReadCloser(*net/http.body) ...,
		GetBody: nil,
		ContentLength: 364,
		TransferEncoding: []string len: 0, cap: 0, nil,
		Close: false,
		Host: "localhost:180",
		Form: net/url.Values nil,
		PostForm: net/url.Values nil,
		MultipartForm: *mime/multipart.Form nil,
		Trailer: net/http.Header nil,
		RemoteAddr: "172.27.0.1:40286",
		RequestURI: "/auth/register",
		TLS: *crypto/tls.ConnectionState nil,
		Cancel: <-chan struct {} {},
		Response: *net/http.Response nil,
		ctx: context.Context(*context.cancelCtx) ...,
		pat: *net/http.pattern nil,
		matches: []string len: 0, cap: 0, nil,
		otherValues: map[string]string nil,},
	reqBody: io.ReadCloser(*net/http.body) *{
		src: io.Reader(*io.LimitedReader) ...,
		hdr: interface {} nil,
		r: *bufio.Reader nil,
		closing: false,
		doEarlyClose: true,
		mu: (*sync.Mutex)(0xc0004182ac),
		sawEOF: false,
		closed: false,
		earlyClose: false,
		onHitEOF: net/http.(*connReader).startBackgroundRead-fm,},
	cancelCtx: context.WithCancel.func1,
	wroteHeader: false,
	wroteContinue: false,
	wants10KeepAlive: false,
	wantsClose: false,
	canWriteContinue: sync/atomic.Bool {
		_: sync/atomic.noCopy {},
		v: 0,},
	writeContinueMu: sync.Mutex {state: 0, sema: 0},
	w: *bufio.Writer {
		err: error nil,
		buf: []uint8 len: 2048, cap: 2048, [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...+1984 more],
		n: 0,
		wr: io.Writer(*net/http.chunkWriter) ...,},
	cw: net/http.chunkWriter {
		res: *(*"net/http.response")(0xc0004540e0),
		header: net/http.Header nil,
		wroteHeader: false,
		chunking: false,},
	handlerHeader: net/http.Header [
		"Access-Control-Allow-Origin": ["*"], 
		"Access-Control-Allow-Credentials": ["true"], 
		"Access-Control-Allow-Methods": [
			"POST, GET, OPTIONS, PUT, DELETE",
		], 
		"Access-Control-Allow-Headers": [
			"Content-Type, Authorization",
		], 
	],
	calledHeader: true,
	written: 0,
	contentLength: -1,
	status: 0,
	closeAfterReply: false,
	fullDuplex: false,
	requestBodyLimitHit: false,
	trailers: []string len: 0, cap: 0, nil,
	handlerDone: sync/atomic.Bool {
		_: sync/atomic.noCopy {},
		v: 0,},
	dateBuf: [29]uint8 [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
	clenBuf: [10]uint8 [0,0,0,0,0,0,0,0,0,0],
	statusBuf: [3]uint8 [0,0,0],
	closeNotifyCh: chan bool {
		qcount: 0,
		dataqsiz: 1,
		buf: *[1]bool [false],
		elemsize: 1,
		closed: 0,
		elemtype: *internal/abi.Type {Size_: 1, PtrBytes: 0, Hash: 2953551688, TFlag: TFlagUncommon|TFlagExtraStar|TFlagNamed|TFlagRegularMemory (15), Align_: 1, FieldAlign_: 1, Kind_: 1, Equal: runtime.memequal8, GCData: *0, Str: 4785, PtrToThis: 203936},
		sendx: 0,
		recvx: 0,
		recvq: waitq<bool> {
			first: *sudog<bool> nil,
			last: *sudog<bool> nil,},
		sendq: waitq<bool> {
			first: *sudog<bool> nil,
			last: *sudog<bool> nil,},
		lock: runtime.mutex {
			lockRankStruct: runtime.lockRankStruct {},
			key: 0,},},
	didCloseNotify: sync/atomic.Bool {
		_: sync/atomic.noCopy {},
		v: 0,},}
