package internal

import (
	"context"
	"errors"
	"fmt"
	"log"
	"time"

	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"

	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/mongo"

	pb "github.com/pongsathonn/ihavefood/src/couponservice/genproto"
	amqp "github.com/rabbitmq/amqp091-go"
)

type CouponService struct {
	pb.UnimplementedCouponServiceServer

	rabbitmq *amqp.Connection
	conn     *mongo.Client
}

func NewCouponService(rb *amqp.Connection, db *mongo.Client) *CouponService {
	return &CouponService{rabbitmq: rb, db: db}
}

func (x *CouponService) AddCoupon(ctx context.Context, in *pb.AddCouponRequest) (*pb.AddCouponResponse, error) {

	if valid := validateCouponTypes(in.CouponType); !valid {
		return nil, status.Errorf(codes.InvalidArgument, "method AddCoupon not implemented")
	}

	if in.Discount < 1 || in.Discount > 99 {
		return nil, status.Errorf(codes.InvalidArgument, "discount must be between 1 and 99")
	}

	if in.Quantity < 1 {
		return nil, status.Errorf(codes.InvalidArgument, "quantity must be at least 1")
	}

	coll := x.conn.Database("coupon_database", nil).Collection("couponCollection")
	expiration := time.Now().Add(in.ExpireInHour * time.Hour)

	var coupon_code string
	switch in.CouponType {
	case pb.CouponType_COUPON_TYPE_DISCOUNT:
		coupon_code = fmt.Sprintf("SAVE%dFORYOU", in.Discount)
	case pb.CouponType_COUPON_TYPE_FREE_DELIVERY:
		coupon_code = fmt.Sprintf("FREEDELIVERY")
	}

	coupon := pb.Coupon{
		Types:      in.CouponType,
		Code:       coupon_code,
		Discount:   in.Discount,
		Expiration: expiration.Unix(),
		Quantity:   in.Quantity,
	}

	coll.InsertOne(ctx, coupon)

	return nil, status.Errorf(codes.Unimplemented, "method AddCoupon not implemented")
}

// TODO doc
func (x *CouponService) GetCoupon(ctx context.Context, in *pb.GetCouponRequest) (*pb.GetCouponResponse, error) {

	if in.Code == "" {
		return nil, status.Errorf(codes.InvalidArgument, "code must be provided")
	}

	coll := x.conn.Database("coupon_database", nil).Collection("couponCollection")

	filter := bson.M{"code": in.Code}

	var coupon *pb.Coupon
	err := coll.FindOne(ctx, filter).Decode(coupon)
	if err != nil {
		if errors.Is(err, mongo.ErrNoDocuments) {
			return nil, status.Errorf(codes.NotFound, "coupon not found")
		}
		log.Println("Decode failed : %v", err)
		return nil, status.Errorf(codes.Internal, "failed to query coupon")
	}

	return &pb.GetCouponResponse{Coupon: coupon}, nil
}

func (x *CouponService) ListCoupon(context.Context, *pb.Empty) (*pb.ListCouponResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListCoupon not implemented")
}

func validateCouponTypes(couponType pb.CouponType) bool {
	switch couponType {
	case pb.CouponType_COUPON_TYPE_DISCOUNT, pb.CouponType_COUPON_TYPE_FREE_DELIVERY:
		return true
	default:
		return false
	}
}
